<center><font size = 10 face = '黑体'>《MySQL存储引擎定制开发》实验报告</font></center>



 

| 题目 | MySQL存储引擎定制开发 |
| :--: | --------------------- |

| 小组成员信息 |
| :----------: |

| 姓名   | 学号     | 班级     | 分工                                 |
| ------ | -------- | -------- | ------------------------------------ |
| 陈杰鹏 | 20337178 | 计科二班 | 数据查询、数据插入、表重命名、表删除 |
| 陈瀚翔 | 20337177 | 计科二班 | 数据更新、数据删除                   |

# 一．开发环境与开发工具：

**开发环境：**Vmware Ubuntu 20.04

**开发工具:** MySQL-5.7.39 ， Clion 2022.3

# 二. 存储引擎功能需求分析

​		MySQL 是支持动态可插拔的储存引擎体系架构，从而可以创建新的储存引擎并直接将其添加到正在运行的 MySQL 中，而无需重新编译 MySQL。这种架构使得为 MySQL 开发新的储存引擎和部署变得更加容易。  
​		MySQL存储引擎是保存数据的核心技术，也就是说，存储引擎是服务于存储服务的，通过存储引擎将数据保存，MySQL的insert、delete等SQL语句，都是由存储引擎来完成结果生成的。  
​		MySQL服务器以模块化方式构建：存储引擎管理的数据存储和索引管理 MySQL。MySQL 服务器与存储引擎通信 通过定义的 API。每个存储引擎都是一个类，其中包含该类的每个实例 通过特殊接口与MySQL服务器通信。handler处理程序基于每个线程的一个处理程序进行实例化 这需要使用特定的表。例如：如果三个 所有连接都开始使用同一个表，三个处理程序 需要创建实例。创建处理程序实例后，MySQL 服务器会发出 处理程序的命令以执行数据存储和检索打开表、操作行和管理等任务 指标。自定义存储引擎可以循序渐进的方式构建：开发人员可以从只读存储引擎开始，然后添加支持和操作，甚至以后添加支持索引、事务和其他高级操作。  
​		同时MySQL也是引擎开发友好的，他为开发者提供了一个example的存储引擎模块，开发者只需要在example模块中基于自己的功能需求来实现即可。  
​		为了更好的将MySQL理论知识与实验相结合，我们决定基于example模块开发支持数据查询、数据插入、数据删除、数据更新的自制引擎，同时还应有表的重命名与删除功能。具体的四个阶段为：

- 生成引擎的方法存根——整个过程的第一步是创建一个可以被插入服务器的基本的存储引擎。创建最基本的源代码文件，为存储引擎从handler基类派生出一个子类，把这个存储引擎本身插入到服务器的源代码里。
- 实现表(文件)操作——能够正确的完成各种必要的文件操作，如创建、打开文件等。
- 实现数据读/写操作——利用MySQL提供的api接口，实现创建、查询功能。
- 实现数据更新和删除操作——实现对存储引擎里的数据进行修改的方法。

​		基于此实验，我们的知识将不再停留在对MySQL的SQL语句接口调用，而是深入到MySQL环境开发与功能设计，加深对MySQL的概念理解。

# 三. 存储引擎模块设计

## a. 数据查询模块



## b. 数据插入模块



## c. 数据删除模块



## d. 数据更新模块



## e. 表重命名模块



## f. 表删除模块



# 四. 存储引擎功能测试

## 1. 存储引擎的加载

### mysql-5.7.39源码下载

先在https://downloads.mysql.com/archives/community/下载对应的MySQL源码

+++

> Product Version : 5.7.39
>
> Operating System : Source Code
>
> OS Version : All Operating Systems (Generic) (Architecture Independent)
>
> +++

因为MySQL必须要有boost库，下方链接选的是Compress TAR Archive , Includes Boost Headers 。

![](shot/1.png)

下载完成后，mysql-boost-5.7.39.tar.gz解压到你选定的文件夹下，指定指令为`tar -xvzf mysql-boost-5.7.39.tar.gz`  

解压完成后会得到名为`mysql-5.7.39`的文件夹，接下来的操作是，因为我们想要方便访问自己的数据库，所以我们要指定data的存放路径datadir，同时为了不破坏mysql-5.7.39的原生文件夹，我们决定用名为build_out的文件夹来存放cmake生成的文件，具体操作：

- 在mysql-5.7.39目录下打开终端
- 执行`mkdir build_out`
- `cd build_out`
- `mkdir data`

接下来就是对我们的存储引擎文件夹的创建，我们来到mysql-5.7.39/storage文件夹，在里面创建一个名为**dbf**的文件夹`mkdir dbf`，然后把我们的`ha_dbf.h`、`ha_dbf.cc`、`CMakeLists.txt`放进去。

最后是对依赖库的安装，在实验中大概需要用到以下库(Vmware Ubuntu下的安装命令)：

+++

> sudo apt-get install make 
> sudo apt-get install gcc 
> sudo apt-get install g++
> sudo apt-get install cmake
> sudo apt-get install openssl
> sudo apt-get install libssl-dev
> sudo apt-get install libncurses5-dev 
> sudo apt-get install bison
>
> +++

### clion下载和配置

到这里mysql-5.7.39的源码下载、文件夹创建以及所需要的库的安装工作已经完成，接下来是对clion的配置,首先说一下为什么需要用到clion，一开始项目是在mysql/5.7.39/build_out/bin中运行`./mysqld`和`./mysql`来测试的，但是这样运行mysqld，在实现了查询功能之后，mysqld会自动崩溃，而使用clion则没有这种情况。

- 在Vmware Ubuntu中，可以用snap install来下载clion，执行命令为`sudo snap install clion --classic`  

- 安装完成后在终端输入`clion`，即可启动clion，接下来是你的用户登录步骤，此步骤忽略  

- 接下来打开你的mysql-5.7.39文件夹，然后会弹出一个cmake界面，更新的内容如下
  +++

  > Generator : Unix Makefiles
  >
  > CMake options :
  >
  > . -DWITH_DEBUG=1 -DWITH_DBF_STORAGE_ENGINE=1  -DDOWNLOAD_BOOST=1 -DWITH_BOOST=./boost -DCMAKE_INSTALL_PREFIX=build_out -DMYSQL_DATADIR=build_out/data 
  >
  > +++

![](shot/2.png)

​		设置完成后点击apply，这时候就会开始cmake过程。若出现链接库缺失的情况，请根据提示下载对应的链接库。  

- 在cmake完成后，在clion的终端窗口输入`make && make install`
  ![](shot/3.png)

​		make的过程比较久，make install也有可能需要管理员权限，若提示则换成`sudo make install `

- 接下来我们要配置my.cnf文件，`ctrl+alt+T`进入终端，`sudo -i`进入权限模式 ，然后`vim /etc/my.cnf`用vim打开my.cnf文件，输入如下:
  +++

  >[mysqld]
  >datadir=/home/jp/code/mysql-5.7.39/build_out/data
  >lc-messages-dir=/home/jp/code/mysql-5.7.39/build_out/share
  >character-set-server=utf8mb4
  >collation-server=utf8mb4_bin
  >
  >[client]
  >default-character-set=utf8mb4
  >
  >[mysql]
  >default-character-set=utf8mb4
  >
  >+++

  datadir和lc-messages-dir都需要根据你的mysql-5.7.39的路径来指定。在vim中`insert`键是开始写入，然后ESC，输入`:wq`是保存并退出

  ![](shot/4.png)

- 接下来就是mysqld初始化用户并获得初始化密码，在mysql-5.7.39/build_out/bin下输入`./mysqld --initialize --user=root`，user可以为你指定，运行成功的话最后一行会返回一个初始密码，一开始需要用这个密码来登录，后续需要自己更改；如果为了测试方便的话，可以像我一样在my.cnf中加入`skip-grant-tables`，这样就不需要用户登录了。

- 初始化之后我们开始运行mysqld，在clion右上方有一个debug的选项，点击一下，然后点击里面的`Edit configurations`
  ![](shot/5.png)

​		然后输入`mysqld`，找到mysqld，在Program Arguements一行输入`--defaults-file=/etc/my.cnf --debug=d,info:F:L`	![](shot/6.png)

​		完成后点击应用，最后点击右上方的debug三角，即可运行mysqld

​		运行成功的画面如下：

![](shot/7.png)

对于数据库的连接，我们可以选择mysql-5.7.39/build_out/bin里的mysql，运行`./mysql` ，也可以选择远程连接数据库，但是需要关闭掉虚拟机的防火墙，关闭命令为:

+++

>1:查看防火状态systemctl status firewalld
>
>service  iptables status
>
>2:暂时关闭防火墙
>
>systemctl stop firewalld
>
>service  iptables stop
>
>3:永久关闭防火墙
>
>systemctl disable firewalld
>
>chkconfig iptables off
>
>4:重启防火墙
>
>systemctl enable firewalld
>
>service iptables restart 
>
>+++

关闭后在在远程的Workbench，输入虚拟机对应的ip，端口为3306，然后输入root和密码进行连接。

## 2. 表的创建

在第一步开启了mysqld之后，我们在mysql-5.7.39/build_out/bin中运行`./mysql`，即可进入数据库。  

数据库的信息是存放在mysql-5.7.39/build_out/data里面的，我们先查看里面是否有数据库  

![](shot/8.png)

然后在mysql-5.7.39/build_out/bin中运行`./mysql`，即可连接：

![](shot/9.png)

接下来我们创建一个名为`jxgl`的数据库，我们先输入`use jxgl`，确保jxgl数据库还没被创建。  

![](shot/10.png)

然后我们创建jxgl数据库`create database jxgl;`

![](shot/11.png)

这时候再查看mysql-5.7.39/build_out/data，会看到多生成了一个名为jxgl的文件夹，这就是我们新建的数据库。

![](shot/12.png)

查看jxgl，只有一个.opt文件

![](shot/13.png)

接下来进行表的创建，命令为

```sql
use jxgl;
create table sc(id int,name char(7),age int)engine=dbf;
```

![](shot/18.png)

![](shot/14.png)

创建成功，再查看一下jxgl文件夹  

![](shot/15.png)

生成了sc.dbe文件，.dbe是dbf引擎中命名的文件后缀。

## 3. 数据插入

用2.表的创建中创建的`sc(id int,name text,age int)engine=dbf`来进行插入，首先查看一下当前表中信息：  

```sql
select * from sc;
```

![](shot/16.png)

接下来进行插入操作，首先尝试单条插入  

```sql
insert into sc values(1,'chen',20);
select * from sc;
```

![](shot/17.png)

单条插入成功  

然后尝试多条插入  

```sql
insert into sc values(2,'wang',18),(3,'li',19),(4,'zhang',21);
select * from sc;
```

![](shot/19.png)

**注：**在测试的时候我尝试过对text类型进行测试，但是发现text类型是会出错的，可能是mysql-5.7.39还没有对text类型完全兼容，具体错误如下：

我们创建一个含有text的数据库sc

```sql
use jxgl;
create table sc(id int,name char(7),age int)engine=dbf;
```

![](shot/20.png)

先进行单条插入  

```sql
insert into sc values(1,'chen',20);
select * from sc;
```

![](shot/17.png)

此时还没有什么问题，但是再插入一条，会发现先前插入的name会变成对应长度的最后插入的name，如：

```sql
insert into sc values(2,'wang',18),(3,'li',19),(4,'zhang',21);
select * from sc;
```

![](shot/21.png)

因为这个传进来的内容是mysql来做的而不是引擎，所以我也无法进行修改，但是char类型是不会出错的。综上，目前所实现的引擎对text类型不兼容，只能用char类型。

## 4. 数据更新



## 5. 数据删除



## 6. 表的重命名

先查看一下jxgl里有什么表

![](shot/15.png)

我们用2.表的创建中创建的sc表来进行，命令为

```sql
rename table sc to s;
```

![](shot/24.png)

再次查看jxgl数据库，可以发现sc.dbe和sc.frm变成了s.deb和s.frm

![](shot/25.png)

这时候对s表进行操作，也是成功的。

![](shot/26.png)

而对sc表进行操作，就会报错  

![](shot/27.png)

## 7. 表的删除

首先查看jxgl中有什么表  

![](shot/15.png)

我们用2.表的创建中创建的sc表来进行，命令为

```sql
drop table sc;
```

![](shot/22.png)

这时候再去查看jxgl，会发现原先创建的sc.deb和sc.frm已经不见了

![](shot/23.png)

删除成功。

接下来再对sc表进行操作，就会报错  

![](shot/27.png)

# 五. 总结
